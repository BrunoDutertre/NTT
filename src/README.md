# Sources


## NTT Implementations

The various algorithms are parametric in Q and n. Q is the prime order of the finite field, and is 
always assumed to be 12289. n is the degree of the polynomials under consideration. 
n must be a power of two, no larger than 2048. In addition, the NTT is based on two parameters
``phi`` and ``psi`` such that ``phi^n = 1`` and ``psi^2 = phi``.

We include four variant implementations of the basic algorithms:
- naive implementation (unoptimized modular arithmetic)
- default implementation (optimized modular arithmetic for Q=12289)
- implementation in C based on the Longa-Naehrig reduction
- implementation in x86-64 assembler that uses the AVX2 vector instruction (also using the Longa-Naehrig reduction)

Each source file includes variant procedures for constructing forward and backward transforms, using either
the Cooley-Tukey or the Gentleman-Sande approaches. Some variants implement pre or post-multiplication by
powers of ``psi``. The source files also include utilities for shuffling array components, multiplying
by scalars, amd more utilities that can be used to implement products of polynomials.

The main source files include:
- ``naive_ntt.c`` and ``naive_ntt.h``: naive implementation
- ``ntt.c`` and ``ntt.h``: default implementation
- ``ntt_red.c`` and ``ntt_red.h``: Longa-Naehrig reduction (C implementation)
- ``ntt_asm.S`` and ``ntt_asm.h``: Longa-Naehrig reduction (assembler/AVX2 implementation)

For testing and experimentation, we instantiate the generic procedures for n=16, 256, 512, and 1024,
and for fixed values of the parameters ``phi`` and ``psi``.
For example ``ntt1024.c`` uses the default NTT procedure (from ``ntt.h`` and ``ntt.c``). 
It is specialized for ``n=1024`` and it includes five procedures that compute products of polynonials.
The five procedures are semantically equivalent but they use different forward/backward transforms.

## Tables

All the NTT procedures we implement take a table of constants as argument.
This table is derived from the parameters ``phi``, ``psi``, and ``n``.  We include
two utilies that generate the relevant tables based on these parameters.

* `make_tables` generates tables suitable for ``naive_ntt`` and ``ntt``. The resulting
   tables are in ``ntt_[16, 256, 512, 1024]_tables.h``.

* `make_red_tables` generates suitable tables for ``ntt_red`` and ``ntt_asm``. 
   The resulting tables are in ``ntt_red[16, 256, 512, 1024]_tables.h``.

For shuffling array elements in the bit-reverse order, we also use a table that defines
an index permutation and we include a utility to generate this table:

* `bitrev[16, 256, 512, 1024]_table.h` are generated by `make_bitrev_table`


## Tests

Basic tests include

```
test_ntt
test_ntt_red
test_ntt_avx
```
These run a first round of tests to validate the implementations and a second
round of tests to measure speed.

The following variants do more extensive testing and are specialized for a fixed ``n``:

```
test_naive_ntt[16, 256, 512, 1024]
test_ntt[16, 256, 512, 1024]
test_ntt_red[16, 256, 512, 1024]
test_ntt_red_asm[16, 256, 512, 1024]
```

We also include Known Answer Tests (kat) for n=1024:
```
data_poly1024.[ch]
kat_mul1024[, _red, red_asm].c
speed_mul1024[, _naive, _red, _red_asm].c
```

The tests in the paper can be found in this [subdirectory](https://github.com/SRI-CSL/NTT/tree/master/src/tests_in_paper). To make them one can simply do
```
make paper_tests
```
in *this* directory (not the subdirectory).



