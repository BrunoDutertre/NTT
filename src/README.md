# The Sources


## The Implementations

The various algorithms are parametric in Q and n. Q is the prime order of the finite field, and is always assumed to be 12289. 
n is the degree of the polynomials under consideration, and varies over various powers of 2.

The main algorithms for parametric n are in the files:
```
naive_ntt.[ch]
```
contains various implementations of the naive algorithm, including the Cooley-Tukey, and Gentleman-Sande variants.
As does:
```
ntt.[ch]
```

```
ntt_asm.[h,S]
```

```
ntt_red.[ch]
```

If a file has a number in it, that number is the fixed value that n is assumed to take. Thus
```
naive_ntt[16, 256, 512, 1024].[ch]
```
contain implementations of polynomial multiplication using naive versions of the NTT for fixed n = 16, 256, 512, and 1024. More details are contained in the 
respective header files.
```
ntt[16, 256, 512, 1024].[ch]
```
These fixed n versions depend on precomputed tables. Explicitly

* `naive_ntt[16, 256, 512, 1024].c` depends on `ntt[16, 256, 512, 1024]_tables.h`

* `ntt[16, 256, 512, 1024].c` depends on `ntt[16, 256, 512, 1024]_tables.h`

The more sophisticated, fixed n, variants can be found in:

```
ntt_red[16, 256, 512, 11024].[ch]
```

* `ntt_red[16, 256, 512, 1024].c` depends on `ntt_red[16, 256, 512, 1024]_tables.h`, `ntt.[ch]`, `ntt_red.[ch]`, 
and the `bitrev[16, 256, 512, 1024]_table.h`

```
ntt_red_asm[16, 256, 512, 1024].[ch]
```

* `ntt_red_asm[16, 256, 512, 1024].c` depends on `ntt_red[16, 256, 512, 1024]_tables.h`, `ntt.[ch]`, `ntt_asm.[hS]`, `ntt_red.[ch]`, 
and the `bitrev[16, 256, 512, 1024]_table.h`

## The Tables

The lookup tables are automatically generated by specifying an n and a psi.

* `ntt_[16, 256, 512, 1024]_tables.h` are generated by `make_tables`

* `ntt_red[16, 256, 512, 1024]_tables.h` are generated by `make_red_tables`

* `bitrev[16, 256, 512, 1024]_table.h` are generated by `make_bitrev_table`


## The Tests

There are 

```
test_ntt
test_ntt_red
test_ntt_avx
test_avx
test_ntt[16, 256, 512, 1024]
test_naive_ntt[16, 256, 512, 1024]
test_ntt_red[16, 256, 512, 1024]
test_ntt_red_asm[16, 256, 512, 1024]
```

For n=1024 there are Known Answer Tests (kat):
```
data_poly1024.[ch]
kat_mul1024[, _red, red_asm].c
speed_mul1024[, _naive, _red, _red_asm].c
```

Testing bounds on the reduction function:

